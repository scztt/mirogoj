{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf460
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;
\red0\green115\blue0;\red96\green96\blue96;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs22 \cf2 ////////  REMEMBER TO UPDATE THE ROUTING IN THE BREATH CLASS FOR ALL 40 SPKRS //////////\cf3 \
\cf4 MiroEnvironment\cf3 .get(\cf5 \\sinc5_respiraciones\cf3 ).push;\
\
~init = \{\
\
	\cf6 "BREATHS INITIALIZED - SYNCHRONY 5"\cf3 .postln;\
\
\};\
\
~prepare = \{\
\
	~atsfile = \cf4 AtsFile\cf3 .new(\cf6 "/Users/Shared/in_ex_13.ats"\cf3 , s).load;\
\
	 \cf2 /////////// MATCH THE NUMBER OF BREATHS //////////////\cf3 \
	~breaths = 6.collect(\{ \cf4 | i |\cf3 \
		\cf4 var\cf3  cluster, skipBand;\
		cluster = [0,2,3,5,7,10];\
		skipBand = [3,4,23,9,16,18]; \cf2 // or 23 in place of 2\cf3 \
\cf2 //		skipBand = [23,17,13,8,4,2];\cf3 \
		\cf4 Breath\cf3 .new( s, cluster[i], ~atsfile.bufnum, ~atsfile.sndDur, 0.384, skipBand[i], 5, -12.dbamp );\
		\});\
	\
	~midpnts = [0.384,0.384,0.384,0.384,0.384,0.384];\
	\
	~breathclock = \cf4 TempoClock\cf3 .new;\
	 	\cf2 /////////// THE SYNCHRONY TASK ///////////\cf3 \
	~breathTask = \cf4 Task\cf3 (\{\
		\cf4 var\cf3  totaldur, numUnisons, unisonCount, widths, delayenv, xpandenv, holdenv, durenv, maxdelay, breathfinish, wait, now, finalBreath;\
		totaldur = 180;\
		numUnisons = 3;\
		unisonCount = 0;\
		widths = [0.65, 0.25, 0.5, 0.9]; \cf2 // sync width, uni1 width, uni2 width, uni3 width\cf3 \
		delayenv = \cf4 Env\cf3 ([25, 0],[totaldur], [-4]); \cf2 // maxdelay for the syncing -0, and staggering -higher delay\cf3 \
		xpandenv = \cf4 Env\cf3 ([0.1,0.95,0.4],[0.75, 0.25]*totaldur, [-2, 1]);\
		holdenv = \cf4 Env\cf3 ([1.5, 1, 3],[totaldur/2, totaldur/2], [-2]);	\cf2 // holding inhales longer as time goes on\cf3 \
		durenv = \cf4 Tendency\cf3 .new( \cf2 // one breath's duration\cf3 \
					\cf4 Env\cf3 ([22, 7, 14],[totaldur/2, totaldur/2], [2]),  \cf2 //tendencies close in on 12 by the end\cf3 \
					\cf4 Env\cf3 ([10, 3, 14],[totaldur/2, totaldur/2], [-2]));\
		\cf2 //~breathclock = TempoClock.new;\cf3 \
		breathfinish = 6.collect(\{ 0 \});  \cf2 /////////// MATCH THE NUMBER OF BREATHS //////////////\cf3 \
		finalBreath =  \cf4 false\cf3 ;\
		now = 0.0;\
		wait = 0.0;\
		block(\{ \cf4 |break|\cf3 \
			\cf4 inf\cf3 .do(\{ \cf4 |i|\cf3 \
				now = now + wait;\
				\cf6 "now: "\cf3 .post; now.postln;\
				maxdelay = delayenv[now];\
				\cf6 "max delay: "\cf3 .post; maxdelay.postln;\
				\
				~breaths.do(\{ \cf4 | breath, i |\cf3 \
					\cf4 var\cf3  startinhale, hold, thisdur, startxhale, thisexpand;\
					\
					(now >= breathfinish[i]).if( \{	\cf2 //make a new breath if the exhale is finished\cf3 \
						\cf2 //"restarting breath: ".post; i.postln;\cf3 \
						startinhale = 0.0.rrand(maxdelay); \cf2 // when the inhale starts from now\cf3 \
	\cf2 //					("this delay is " ++ startinhale.asSymbol).postln;\cf3 \
						hold = holdenv[now];\
						thisdur = durenv[now+startinhale];\
						\cf6 "this dur "\cf3 .post; thisdur.postln;\
						startxhale = startinhale + (~midpnts[i]*thisdur) + hold;\
						thisexpand = xpandenv[now+startinhale];\
						\cf2 //"thisexpand: ".post; thisexpand.postln;\cf3 \
						\
						~breathclock.sched( startinhale,\
							\{ breath.inhale( thisdur, thisexpand, widths[ unisonCount ] ) \} );\
						~breathclock.sched( startxhale,\
							\{ breath.exhale \} );\
							\
							\cf2 //keep track of when this breath will finish\cf3 \
						breathfinish[i] = thisdur+hold+now;\
						\});\
					\});\
				\
					\cf2 // auto cleanup\cf3 \
				(unisonCount==numUnisons).if(\{ \
					((durenv[now]+holdenv[now]) * 1.2).wait;\
					~breaths.do(\{ \cf4 | breath |\cf3  breath.free \});\
					\cf6 " BREATH HAS BREATHED ITS LAST BREATH "\cf3 .postln;\
					\cf2 // ~this.cleanup\cf3 \
					break.value();\
					\});\
					\
				wait = rrand(1.1, 4);\
				(now > totaldur).if(  \cf2 // if now has passed the total dur...\cf3 \
					\{	\cf6 "WE'RE DONE! - numUnison more breaths now, all together"\cf3 .postln; \
						wait = ((durenv[now]+holdenv[now]) * 0.8).postln; \
						unisonCount = unisonCount+1;\
						finalBreath=\cf4 true\cf3 ;  \cf2 // for stopping itself\cf3 \
					\});\
				wait.wait;\
				\
				\})\
			\})\
		\}, ~breathclock);\
\
	\cf6 "BREATHS PREPARED - SYNCHRONY 5"\cf3 .postln;\
\
\};\
\
~play = \{\
\
	~breathTask.play;\
	\
	\cf6 "BREATHS PLAYING - SYNCHRONY 5"\cf3 .postln;\
\
\};\
\
~free = \{\
	~breathTask.stop.reset;\
	~breaths.do(\{ \cf4 | breath |\cf3  breath.free \}); \cf2 // for early stopping\cf3 \
	~breathclock.clear;\
	~atsfile.freeBuffer;\
	~atsfile = ~breaths = ~breathTask = ~breathclock = ~midpnts = \cf4 nil\cf3 ;\
\
	\cf6 "BREATHS FREEING - SYNCHRONY 5"\cf3 .postln;\
\
\};\
\
\cf4 MiroEnvironment\cf3 .get(\cf5 \\sinc5_respiraciones\cf3 ).pop;\
\cf2 //MiroEnvironment.gui}